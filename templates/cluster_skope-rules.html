<!DOCTYPE html>
<html lang='en'>


<head>
	<meta charset="UTF-8">
	<title>TEST</title>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<script src="https://code.jquery.com/jquery-1.4.1.min.js"></script>
</head>

<body>

  

<p>
Here is a dataset banknote.csv. we use xgboost as the model and calculate the shap values.</p>
<p>
The left graph shows the shap values after {{rd}} .
The right graph shows the data values after {{rd}} .</p>


<p>
You can choose a segment(some points) in the graph, we will give you a rule(skope-rules) corresponding to that segment.
You have 3 ways to choose the segment, by hand or kmeans or dbscan.
</p>

<br>

<div id="choosebyhand">
	1.Please choose some points by hand in the left graph
	<button type="submit" id="btn" onclick = "btn()" >Skope-rules</button>
	
	
</div>
   
<br>


<div id="formkmeans">
    <form id="kmeans" name ="form1" onsubmit="return false" action="##" method="post">
	2.K-means <br>number of clusters: <input type="text" name="ncl">
        <input type="button" value="cluster" onclick="kmeansbtn()" value ="Kmeans">
    </form>
    <form id="kmeans_skope" name ="form2" onsubmit="return false" action="##" method="post">
    	choose one cluster to skope-rule: <input type="text" name="clusterchosen">
        <input type="button" value="Skope-rules" onclick="Skope(0)" value ="skope">
    </form>
</div>




<br>

<div id="formdbscan">
    <form id="dbscan" name ="form3" onsubmit="return false" action="##" method="post">
	3.DBSCAN<br>    epsilon: <input type="text" name="epsilon">
		M: <input type="text" name="M">
        <input type="button" value="cluster" onclick="dbscanbtn()" value ="Kmeans">
    </form>
    <form id="dbscan_skope" name ="form4" onsubmit="return false" action="##" method="post">
    	choose one cluster to skope-rule: <input type="text" name="clusterchosen2">
        <input type="button" value="Skope-rules" onclick="Skope(1)" value ="skope">
    </form>
</div>



<svg width="2000" height="1000" id="mainsvg" class="svgs"></svg>
  
  
<script>
      // The following code is the typical routine of my d3.js code. 
      const svg = d3.select('svg');
      const width = svg.attr('width');
      const height = svg.attr('height');
      const margin = {top: 200, right: 30, bottom: 100, left: 150};
      const innerWidth = width - margin.left - margin.right;
      const innerHeight = height - margin.top - margin.bottom;
      const mainGroup1 = svg.append('g')
      .attr('transform', `translate(${margin.left}, ${margin.top})`)
      
      const mainGroup2 = svg.append('g')
      .attr('transform', `translate(${margin.left+innerWidth*3/5},${margin.top})`)
      
      
      const xValue = (d => d.shap0);
      const yValue = (d => d.shap1);
      function color(d){return d.label==0 ? 'red':'green';}
      
      
      const xScale = d3.scaleLinear();
      const yScale = d3.scaleLinear();

      const x1Value= d => d.x0;
      const x2Value= d => d.x1;
      const x1Scale = d3.scaleLinear();
      const x2Scale = d3.scaleLinear();

      /* 
        Loading data and preprocessing data. 
        Note that you can also preprocessing data in your own way using your prefered language, e.g., Python. 
      */
      
	var Datalength=0
      
	var c = new Array();//for later use
    
      d3.csv('{{filename}}').then(data => {
          // calculationg scales:   
         
          Datalength=data.length;
                  
          let a1=Infinity
          let a2=Infinity
          let b1=-Infinity
          let b2=-Infinity
          
          let sa1=Infinity
          let sa2=Infinity
          let sb1=-Infinity
          let sb2=-Infinity
          
          for(i=0;i<Datalength;i++){
          	let x1=parseFloat(x1Value(data[i]))
          	let x2=parseFloat(x2Value(data[i]))
          	let s1=parseFloat(xValue(data[i]))
          	let s2=parseFloat(yValue(data[i]))
          	if (x1<a1){
          		a1 = x1}
          	else if (x1>b1)
          		{b1=x1}
          	if (x2<a2)
          		{a2 =x2}
          	else if (x2>b2)
          		{b2=x2}
          	
          	if (s1<sa1)
          		{sa1 = s1}
          	else if (s1>sb1)
          		{sb1=s1}
          	if (s2<sa2)
          		{sa2 =s2}
          	else if (s2>sb2)
          		{sb2=s2}         		
          }
                      	    
                      	    
          // for the variable space
          x2Scale.domain([1.1*a2,1.1*b2]).range([0, innerHeight]);
          x1Scale.domain([1.1*a1,1.1*b1]).range([0, innerWidth*2/5]);   

          
          // data-join for circle:  
          const myCircle2 = mainGroup2.append('g').selectAll('circle').data(data).join('circle')
          .attr('cx',d => x1Scale(x1Value(d))).attr('cy',d => x2Scale(x2Value(d))).attr('r',3)
          .attr("fill", d=>color(d))
            .attr('class',function(d,i){ return 'class'+i;})
  		        
          // adding axes:       
          const x1AxisMethod = d3.axisBottom(x1Scale);
          const x2AxisMethod = d3.axisLeft(x2Scale);
          
          const x1AxisGroup = mainGroup2.append('g').call(x1AxisMethod)
                .attr('transform', `translate(${0}, ${innerHeight})`)
		.append('text') // ----------
		.text('x1')
		.attr('font-size', '3em')
		.attr('x', innerWidth / 5)
		.attr('y', 50)
		.attr('text-anchor', 'middle')
		.attr('fill', 'black');
	 
          const x2AxisGroup = mainGroup2.append('g').call(x2AxisMethod)
		.append('text') // ----------
		.text('x2')
		.attr('font-size', '3em')
		.attr('transform', 'rotate(-90)') // y-axis label needs an additional transform; 
		.attr('x', -innerHeight / 2)
		.attr('y', -50)
		.attr('text-anchor', 'middle')
		.attr('fill', 'black');
      
      
      	  c = new Array(data.length); 
	  for(i=0;i<data.length;i++) {c[i]=0;}
	  
		//for the explication(SHAP) space
		 
          yScale.domain([1.1*sa2,1.1*sb2]).range([0, innerHeight]);
          xScale.domain([1.1*sa1,1.1*sb1]).range([0, innerWidth*2/5]);   
        
          const xAxisMethod = d3.axisBottom(xScale);
          const yAxisMethod = d3.axisLeft(yScale);
   
          const xAxisGroup = mainGroup1.append('g').call(xAxisMethod)
                .attr('transform', `translate(${0}, ${innerHeight})`)
		.append('text') // ----------
		.text('shap1')
		.attr('font-size', '3em')
		.attr('x', innerWidth / 5)
		.attr('y', 50)
		.attr('text-anchor', 'middle')
		.attr('fill', 'black');
				 
          const yAxisGroup = mainGroup1.append('g').call(yAxisMethod)
		.append('text') // ----------
		.text('shap2')
		.attr('font-size', '3em')
		.attr('transform', 'rotate(-90)') // y-axis label needs an additional transform; 
		.attr('x', -innerHeight / 2)
		.attr('y', -50)
		.attr('text-anchor', 'middle')
		.attr('fill', 'black');
		
	 const myCircle1 = mainGroup1.append('g').selectAll('circle').data(data).join('circle')
          .attr('cx',d => xScale(xValue(d))).attr('cy',d => yScale(yValue(d))).attr('r',3)
          .attr("fill", d=>color(d))
        .attr('class',function(d,i){ return 'class'+i;})
        ;
        
        
        
        //add a brush in the explication space, which blacked out the points selected, and blacked out the corresponding points in the variable space
       mainGroup1
	      .call( d3.brush()                   
        			.extent( [ [0,0], [width/2,height] ] )     
        			.on("start end", updateChart)
      		)   
	

	function updateChart() {  
		const selection = d3.brushSelection(this)
		if (selection==null)
			return
		for(i=0;i<data.length;i++){
			if(isBrushed(selection, xScale(xValue(data[i])), yScale(yValue(data[i])))){
				c[i]=1
			}
			else{c[i]=0}
		}
		myCircle1.attr('fill',function(d,i){return isBrushed(selection, xScale(xValue(d)), yScale(yValue(d)))? 'black': color(d)})
		myCircle2.attr('fill',function(d,i){return isBrushed(selection, xScale(xValue(d)), yScale(yValue(d)))? 'black': color(d)})
	}
  // A function that return TRUE or FALSE according if a dot is in the selection or not
	function isBrushed(brush_coords, cx, cy) {
		if (brush_coords==null)
		return false;
		var x0 = brush_coords[0][0],
		   x1 = brush_coords[1][0],
		   y0 = brush_coords[0][1],
		   y1 = brush_coords[1][1];
		return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1; // This return TRUE or FALSE depending on if the points is in the selected area
	}
      })
      	
      	
      	//we need to do kmeans(dbscan) before kmeans_skope(dbscan_skope)	
	document.getElementById("kmeans_skope").style.visibility= "hidden "; 
	document.getElementById("dbscan_skope").style.visibility= "hidden "; 


      	//function of the button "skope-rules"
       function btn(){
       			d3.select("#kmeans").remove()
				d3.select('#dbscan').remove()
       		        var d=c.toString()	//a 0-1 array of size Datalength, means if a point is selected or not 
       			$.ajax({
	       			type:"POST",
	       			url:"/run",
	       			data:{"ids": d
	       			      },
	       			success: function(data){  
	       			      if(data =='0'){// =='0' means no points chosen
		       			       alert("please choose some points");
		       			       }
		       		      else{
						d3.select("#textskope").remove() //remove the previous result
		       		      showresultskope(data)	//show the result of skope-rules
		       		      }
		       			      }
       			})
       		}	
      

      function showresultskope(data){
      		rule=data.rule
      		var textskope = svg.append('g').attr('id','textskope')
      		.attr('transform', `translate(${margin.left}, 50)`)
      		textskope.append('text').text("Nb of points selected: "+data.nop+"   Average prediction: "+data.avp)
      		textskope.append('text').attr('y',14).text("Rule: "+rule.rule)
      		textskope.append('text').attr('y',28).text('  precision: '+rule.precision+" recall: "+rule.recall )    
    		textskope.append('text').attr('y',60).text("Nb of points triggered by the rule: "+data.pfr+"   Average prediction of these points: "+data.avpr)	
      }
      
      
	 function kmeansbtn(){
	  	d3.select("#choosebyhand").remove()
		d3.select('#dbscan').remove()
	 
	 	NoC=document.form1.ncl.value//number of clusters   
	 	if(NoC==null){alert("please enter an integer")}		
	        NoC = parseInt(NoC)
	        if(NoC<=0){alert("please enter an integer")}		
	 	$.ajax({
			type:"POST",
			url:"/kmeans",
			data:{"n": NoC
			      },
			success: function(data){  
					labelcluster = data.slice(start=1,end=-1).split(",")
					for(i=0;i<labelcluster.length;i++){labelcluster[i]=parseInt(labelcluster[i])}
					COLOR_cluster(NoC,labelcluster)
					document.getElementById("kmeans_skope").style.visibility= "visible"; //show the button of skope
					
					Labelcluster = labelcluster
					N_CLUSTER = NoC
	       			      }
       	})
	}
	var Labelcluster = new Array()//an array to store the result of kmeans/dbscan
	var N_CLUSTER = 0
	
	//change the colors of all points according to the result of kmeans/dbscan
	function COLOR_cluster(N,labelcluster){
		
		mainGroup1.select('#legend').remove()
		
		var color1= d3.rgb(255,0,0)
		var color2= d3.rgb(0,255,255)
		var compute = d3.interpolate(color1,color2)
		const colorScale = d3.scaleLinear()
		colorScale.domain([0,N-1]).range([0,1])
		
		mainGroup1.selectAll('circle').attr('fill',function(d,i){return compute(colorScale(labelcluster[i]))})
		mainGroup2.selectAll('circle').attr('fill',function(d,i){return compute(colorScale(labelcluster[i]))})
		
		//add legend
		var legend = mainGroup1.append('g').attr('id','legend')
		var size = innerWidth/(N) *2/5
		for(i=0;i<N;i++){      
		legend.append('circle').attr('cx',i*size).attr('cy',0).attr('r',20)
		.attr('fill',compute(colorScale(i)))
		
		legend.append('text').attr('dx',i*size).text(i).attr('fill','black')
		}
	}
	// Skope(0) for skope-rules after kmeans. Skope(1) for skope-rules after dbscan
	function Skope(j){
		if(j==0)
		 	{n=document.form2.clusterchosen.value}
		if(j==1)
			{n=document.form4.clusterchosen2.value}
		//n is the index of cluster chosen
 		if(n==null){alert("please choose a cluster")}		
		n = parseInt(n)
		if(n<0){alert("please choose a legal cluster")}
		if(n>=N_CLUSTER){alert("please choose a legal cluster")}
		//construct a 0-1 array of size Datalength, 1 means that point is in the cluster chosen
		newlabel = new Array(Datalength)
		for(i=0;i<Datalength;i++){
			newlabel[i]=0
			if(Labelcluster[i]==n){newlabel[i]=1}
		}
		str = newlabel.toString()
		
		$.ajax({
       			type:"POST",
       			url:"/run",
       			data:{"ids": str
       			      },
       			success: function(data){  
       			      if(data =='0'){
	       			       alert("please choose some points");
	       			       }
	       		      else{
					d3.select("#textskope").remove()
	       		      showresultskope(data)
	       		      }
	       			      }
		})	
	}
	
	function dbscanbtn(){
	  	d3.select("#choosebyhand").remove()
		d3.select('#kmeans').remove()
	 	epsilon=document.form3.epsilon.value
		M = document.form3.M.value


	 	if(epsilon==null){alert("please give legal epsilon value")}	
	 	if(M==null){alert("please give legal M value")}			
	        M = parseInt(M)
	        if(M<=0){alert("please give legal M value")}
	        epsilon = parseInt(epsilon)
	        if(epsilon<0){alert("please give legal epsilon value")}	
	      	
	 	$.ajax({
			type:"POST",
			url:"/dbscan",
			data:{"epsilon": epsilon,
				"M": M
			      },
			success: function(data){  
					NoC = parseInt(data.numberofcluster)
					labelcluster = data.label.slice(start=1,end=-1).split(",")
					for(i=0;i<labelcluster.length;i++){labelcluster[i]=parseInt(labelcluster[i])}
					COLOR_cluster(NoC,labelcluster)
					document.getElementById("dbscan_skope").style.visibility= "visible"; 
					Labelcluster = labelcluster
					N_CLUSTER = NoC
	       			}
       	})
		
	}
	
	
</script> 

  
</body>

</html>



